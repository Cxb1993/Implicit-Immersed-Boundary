import IB_c
from Delta import FiberToGrid, GridToFiber

import numpy as numpy
from numpy import array, zeros, float64

from os.path import dirname, join
from SaveData import ensure_dir, ensure_filedir

def GetLookupTable (fluid):
	"""Retrieve a lookup table for the interpolated velocity generated by a point force.
	
	If table does not already exist it will be created and stored."""

	path = join(dirname(dirname(__file__)), "GreensFunction")
	path = join(path, '2D' if fluid.Dim == 2 else '3D')
	
	name = join(path, fluid.Params_ToString() + '.npy')

	try:
		# Load the table from file
		Table = numpy.load(name);
	except:
		# File didn't exist, create table from scratch
		print "Greens function at\n	", name, "\ndoesn't exist, creating it...",
		Table = CalculateLookupTable(fluid)
		
		# Save the new lookup table
		ensure_filedir(name)
		numpy.save(name, Table)
		
		print "Done."
		print

	return Table
	

def CalculateLookupTable(fluid, spread = True, Range = 10000):
	"""Calculate a lookup table for the interpolated velocity generated by a point force.
	
	The table has dimensions N[0]xN[1]x2x2 or N[0]xN[1]xN[2]x3x3."""

	print fluid.N

	Dim = fluid.Dim
	
	if Dim == 2:
		return CalculateLookupTable_2D(fluid, spread, Range)
	else:
		return CalculateLookupTable_3D(fluid, spread, Range)
	
def CalculateLookupTable_2D(fluid, spread = True, Range = 10000):
	U = zeros((fluid.N[0],fluid.N[1],2,2),float64)
	X = zeros((1,2),float64)
	
	F = X.copy()
	
	# Calculate the lookup table for a unit force in the x direction
	F[0] = [1,0]
	
	FiberToGrid(fluid.N, fluid.h, 1, 1., X, F, fluid.f, fluid.DeltaType)
	fluid.FluidSolve(fluid.f)
	
	if (spread):
		IB_c.WholeGridSpread(fluid.Output_u, fluid.N, fluid.h, U[...,0,:], Range, fluid.DeltaType)
	else:
		U[...,0,:] = fluid.Output_u.copy()

	# If the domain is perfectly cubic make use of symmetries
	if fluid.N[0] == fluid.N[1]:
		U[...,1,:] = U[...,0,:].swapaxes(0,1)
		U[...,1,0], U[...,1,1] = U[...,1,1].copy(), U[...,1,0].copy()
	# otherwise calculate y component from scratch
	else:
		# Calculate the lookup table for a unit force in the y direction
		F[0] = [0,1]
		
		FiberToGrid (fluid.N, fluid.h, 1, 1., X, F, fluid.f, fluid.DeltaType)
		fluid.FluidSolve(fluid.f)
		
		if (spread):
			IB_c.WholeGridSpread(fluid.Output_u, fluid.N, fluid.h, U[...,1,:], Range, fluid.DeltaType)
		else:
			U[...,1,:] = fluid.Output_u.copy()

	return U
	
def CalculateLookupTable_3D(fluid, spread = True, Range = 10000):	
	U = zeros((fluid.N[0], fluid.N[1], fluid.N[2], 3, 3), float64)
	X = zeros((1, 3), float64)
	
	F = X.copy()
	
	# Calculate the lookup table for a unit force in the x direction
	F[0] = [1,0,0]
	
	FiberToGrid (fluid.N, fluid.h, 1, 1., X, F, fluid.f, fluid.DeltaType)
	fluid.FluidSolve(fluid.f)
	
	if (spread):
		IB_c.WholeGridSpread(fluid.Output_u, fluid.N, fluid.h, U[...,0,:], Range, fluid.DeltaType)
	else:
		U[...,0,:] = fluid.Output_u.copy()

	# If the domain is perfectly cubic make use of symmetries
	if fluid.N[0] == fluid.N[1] == fluid.N[2]:
		U[...,1,:] = U[...,0,:].swapaxes(0,1)
		U[...,1,0], U[...,1,1] = U[...,1,1].copy(), U[...,1,0].copy()
		U[...,2,:] = U[...,0,:].swapaxes(0,2)
		U[...,2,0], U[...,2,2] = U[...,2,2].copy(), U[...,2,0].copy()
	# otherwise calculate y and z components from scratch
	else:
		# Calculate the lookup table for a unit force in the y direction
		F[0] = [0,1,0]
	
		FiberToGrid (fluid.N, fluid.h, 1, 1., X, F, fluid.f, fluid.DeltaType)
		fluid.FluidSolve(fluid.f)
		
		if (spread):
			IB_c.WholeGridSpread(fluid.Output_u, fluid.N, fluid.h, U[...,1,:], Range, fluid.DeltaType)
		else:
			U[...,1,:] = fluid.Output_u.copy()

		# Calculate the lookup table for a unit force in the z direction
		F[0] = [0,0,1]
		
		FiberToGrid (fluid.N, fluid.h, 1, 1., X, F, fluid.f, fluid.DeltaType)
		fluid.FluidSolve(fluid.f)
		
		if (spread):
			IB_c.WholeGridSpread(fluid.Output_u, fluid.N, fluid.h, U[...,2,:], Range, fluid.DeltaType)
		else:
			U[...,2:] = fluid.Output_u.copy()

	return U


# EXPERIMENTAL HIGHER ACCURACY LOOKUP TABLE. PROBABLY BROKEN RIGHT NOW.
def CalculateLookupTable2 (fluid, M = 4, spread = True, Range = 10000, offset = 0):
	"""Calculates a lookup table for the interpolated velocity generated by a point force
	The table has dimensions 3xN[0]xN[1]xN[2]x3, where the first dimension specifies the direction of the force"""

	if Range > fluid.N[0]:
		Range = fluid.N[0] / 2 + 1
	U = zeros((M+1,M+1,M+1,3,Range,Range,Range,3),float64)

	X = zeros((1,3),float64)
	F = X.copy()

	for j in range(M+1):
		for k in range(M+1):
			for l in range(M+1):
				X[0] = 1. / M * array([j,k,l]) * fluid.h
				X[0] += array([1,1,1]) * fluid.h * offset
				print j, k, l, X[0] / fluid.h, array([1,1,1]) * fluid.h
				
				F[0] = [1,0,0]
				FiberToGrid (fluid.N, fluid.h, 1, 1., X, F, fluid.f, fluid.DeltaType)
				fluid.FluidSolve(fluid.f)
				if (spread):
					IB_c.WholeGridSpread2(fluid.Output_u, fluid.N, fluid.h, U[j,k,l,0], Range, fluid.DeltaType)
					raise ValueError("WholeGridSpread2 not yet implemented")
				else:
					U[j,k,l,0] = fluid.Output_u[:Range,:Range,:Range].copy()

				if fluid.N[0] == fluid.N[1] == fluid.N[2]:
					U[j,k,l,1] = U[j,k,l,0].swapaxes(0,1)
					U[j,k,l,1,:,:,:,0], U[j,k,l,1,:,:,:,1] = U[j,k,l,1,:,:,:,1].copy(), U[j,k,l,1,:,:,:,0].copy()
					U[j,k,l,2] = U[j,k,l,0].swapaxes(0,2)
					U[j,k,l,2,:,:,:,0], U[j,k,l,2,:,:,:,2] = U[j,k,l,2,:,:,:,2].copy(), U[j,k,l,2,:,:,:,0].copy()
				else:
					raise ValueError("CalculateLookupTable2 not implemented for non-cube domains.")

	return U
	
